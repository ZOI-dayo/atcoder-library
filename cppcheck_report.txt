math/modint.hpp:44:25: style:inconclusive: Technically the member function 'dynamic_modint::operator--' can be const. [functionConst]
  inline dynamic_modint operator--(int32_t) {
                        ^
math/modint.hpp:61:15: style:inconclusive: Technically the member function 'dynamic_modint::operator==' can be const. [functionConst]
  inline bool operator==(const dynamic_modint &a) { return _val == a._val; }
              ^
math/modint.hpp:62:15: style:inconclusive: Technically the member function 'dynamic_modint::operator!=' can be const. [functionConst]
  inline bool operator!=(const dynamic_modint &a) { return _val != a._val; }
              ^
math/modint.hpp:139:27: style:inconclusive: Technically the member function 'modint::operator++' can be const. [functionConst]
  constexpr inline modint operator++(int32_t) noexcept {
                          ^
math/modint.hpp:144:27: style:inconclusive: Technically the member function 'modint::operator--' can be const. [functionConst]
  constexpr inline modint operator--(int32_t) noexcept {
                          ^
math/modint.hpp:161:25: style:inconclusive: Technically the member function 'modint::operator==' can be const. [functionConst]
  constexpr inline bool operator==(const modint &a) noexcept {
                        ^
math/modint.hpp:164:25: style:inconclusive: Technically the member function 'modint::operator!=' can be const. [functionConst]
  constexpr inline bool operator!=(const modint &a) noexcept {
                        ^
math/modint.hpp:21:3: style: Struct 'dynamic_modint' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  dynamic_modint(int val) : _val(modint_utils::normalize(val, MOD)) {}
  ^
math/modint.hpp:120:20: style: Struct 'modint' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  constexpr inline modint(int val) noexcept
                   ^
string/rolling-hash.hpp:17:29: performance:inconclusive: Function parameter 'hash' should be passed by const reference. [passedByValue]
  explicit RollingHash(mint hash, int length) : hash(hash), length(length) {}
                            ^
math/modint.hpp:139:27: style:inconclusive: Technically the member function 'modint < 1000000007 >::operator++' can be const. [functionConst]
  constexpr inline modint operator++(int32_t) noexcept {
                          ^
math/modint.hpp:144:27: style:inconclusive: Technically the member function 'modint < 1000000007 >::operator--' can be const. [functionConst]
  constexpr inline modint operator--(int32_t) noexcept {
                          ^
math/modint.hpp:161:25: style:inconclusive: Technically the member function 'modint < 1000000007 >::operator==' can be const. [functionConst]
  constexpr inline bool operator==(const modint &a) noexcept {
                        ^
math/modint.hpp:164:25: style:inconclusive: Technically the member function 'modint < 1000000007 >::operator!=' can be const. [functionConst]
  constexpr inline bool operator!=(const modint &a) noexcept {
                        ^
math/modint.hpp:120:20: style: Struct 'modint < 1000000007 >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  constexpr inline modint(int val) noexcept
                   ^
datastructure/segment-tree.hpp:12:5: style:inconclusive: Member variable 'SegmentTree::_monoid' is in the wrong place in the initializer list. [initializerList]
  M _monoid;
    ^
datastructure/segment-tree.hpp:58:41: note: Member variable 'SegmentTree::_monoid' is in the wrong place in the initializer list.
  SegmentTree(int n, M monoid) : _n(1), _monoid(monoid), e(monoid.e()) {
                                        ^
datastructure/segment-tree.hpp:12:5: note: Member variable 'SegmentTree::_monoid' is in the wrong place in the initializer list.
  M _monoid;
    ^
datastructure/segment-tree.hpp:64:21: performance:inconclusive: Function parameter 'a' should be passed by const reference. [passedByValue]
  void set(int i, T a) {
                    ^
datastructure/lazy-segment-tree.hpp:15:12: style:inconclusive: Member variable 'LazySegmentTree < Monofuncs :: RangeSetMonofunc < Monoids :: MinMonoid < int32_t > > >::e' is in the wrong place in the initializer list. [initializerList]
  const MT e;
           ^
datastructure/lazy-segment-tree.hpp:36:84: note: Member variable 'LazySegmentTree < Monofuncs :: RangeSetMonofunc < Monoids :: MinMonoid < int32_t > > >::e' is in the wrong place in the initializer list.
  explicit inline LazySegmentTree(const int32_t n) : _monoid(M()), _monofunc(F()), e(_monoid.e()), id(_monofunc.id()) {
                                                                                   ^
datastructure/lazy-segment-tree.hpp:15:12: note: Member variable 'LazySegmentTree < Monofuncs :: RangeSetMonofunc < Monoids :: MinMonoid < int32_t > > >::e' is in the wrong place in the initializer list.
  const MT e;
           ^
graph/depth.hpp:12:32: style: Parameter 'graph' can be declared with const [constParameter]
vec<TreeNodeInfo> depth(Graph &graph, int root = 0) {
                               ^
math/modint.hpp:139:27: style:inconclusive: Technically the member function 'modint < MOD >::operator++' can be const. [functionConst]
  constexpr inline modint operator++(int32_t) noexcept {
                          ^
math/modint.hpp:144:27: style:inconclusive: Technically the member function 'modint < MOD >::operator--' can be const. [functionConst]
  constexpr inline modint operator--(int32_t) noexcept {
                          ^
math/modint.hpp:161:25: style:inconclusive: Technically the member function 'modint < MOD >::operator==' can be const. [functionConst]
  constexpr inline bool operator==(const modint &a) noexcept {
                        ^
math/modint.hpp:164:25: style:inconclusive: Technically the member function 'modint < MOD >::operator!=' can be const. [functionConst]
  constexpr inline bool operator!=(const modint &a) noexcept {
                        ^
math/modint.hpp:139:27: style:inconclusive: Technically the member function 'modint < 998244353 >::operator++' can be const. [functionConst]
  constexpr inline modint operator++(int32_t) noexcept {
                          ^
math/modint.hpp:144:27: style:inconclusive: Technically the member function 'modint < 998244353 >::operator--' can be const. [functionConst]
  constexpr inline modint operator--(int32_t) noexcept {
                          ^
math/modint.hpp:161:25: style:inconclusive: Technically the member function 'modint < 998244353 >::operator==' can be const. [functionConst]
  constexpr inline bool operator==(const modint &a) noexcept {
                        ^
math/modint.hpp:164:25: style:inconclusive: Technically the member function 'modint < 998244353 >::operator!=' can be const. [functionConst]
  constexpr inline bool operator!=(const modint &a) noexcept {
                        ^
math/modint.hpp:120:20: style: Struct 'modint < MOD >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  constexpr inline modint(int val) noexcept
                   ^
math/modint.hpp:120:20: style: Struct 'modint < 998244353 >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  constexpr inline modint(int val) noexcept
                   ^
nofile:0:0: information: Cppcheck cannot find all the include files (use --check-config for details) [missingIncludeSystem]

